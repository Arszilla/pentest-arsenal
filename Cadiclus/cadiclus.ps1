$banner = @"

▄████████    ▄████████ ████████▄   ▄█   ▄████████  ▄█       ███    █▄     ▄████████ 
███    ███   ███    ███ ███   ▀███ ███  ███    ███ ███       ███    ███   ███    ███ 
███    █▀    ███    ███ ███    ███ ███▌ ███    █▀  ███       ███    ███   ███    █▀  
███          ███    ███ ███    ███ ███▌ ███        ███       ███    ███   ███        
███        ▀███████████ ███    ███ ███▌ ███        ███       ███    ███ ▀███████████ 
███    █▄    ███    ███ ███    ███ ███  ███    █▄  ███       ███    ███          ███ 
███    ███   ███    ███ ███   ▄███ ███  ███    ███ ███▌    ▄ ███    ███    ▄█    ███ 
████████▀    ███    █▀  ████████▀  █▀   ████████▀  █████▄▄██ ████████▀   ▄████████▀  
                                                   ▀                                 

                                     Version 1.0
                                     Created by: TJ Null
"@

# Print the ASCII banner
Write-Host $banner

# Define the help function
function Show-Help {
    $helpText = @"
General Guidelines:

A PowerShell Script that searches for possibled paths to escalate priviliges on Linux/Unix*/MacOS hosts using PowerShell for Linux. 

"@
#    Write-Host $helpText
}

# Define the function to get OS information and kernel version
function Get-OSInfo {
    $osInfo = [System.Runtime.InteropServices.RuntimeInformation]::OSDescription
    $osReleaseContent = Get-Content /etc/os-release
    $osRelease = @{}
    foreach ($line in $osReleaseContent) {
        if ($line -match '^(.+?)=(.+)$') {
            $key = $matches[1]
            $value = $matches[2].Trim('"')
            $osRelease[$key] = $value
        }
    }

    Write-Host "`n[+] Operating System Kernel Version:"
    Write-Host $osInfo
    Write-Host "`n[+] OS Release Information:"
    foreach ($key in $osRelease.Keys) {
        Write-Host "$key = $($osRelease[$key])"
    }

}

# Define the function to check if the system is joined to a domain controller:
function Check-ADJoinStatus {
    Write-Host "`n[+] Checking if the system is joined to an Active Directory domain..."

    if (Test-Path "$(which realm)") {
        $adStatus = realm list | Select-String -Pattern 'domain-name'

        if ($adStatus) {
            Write-Host "The system is joined to an Active Directory domain."
        } else {
            Write-Host "The system is not joined to an Active Directory domain."
        }
    } else {
        Write-Host "The 'realm' command is not installed on this system."
    }
}


# Define the function to check for local and network drives
function Get-Drives {
    $drives = Get-PSDrive
    Write-Host "`n[+] List of Local and Network Drives:"
    $drives | Format-Table Name, @{Label="Provider";Expression={Provider}}, Root, @{Label="Used (GB)";Expression={[math]::round($_.Used/1GB,2)}}, @{Label="Free (GB)";Expression={[math]::round($_.Free/1GB,2)}}
}

# Define the function to check for current network connections. 
# Note: Get-NetTCPConnection is not supported in PowerShell core at this time: https://github.com/PowerShell/PowerShell/issues/13013
function Get-NetworkActivity {
    Write-Host "`n[+] Grabbing current network connections..."
    $networkActivity = ss -ntlp | ForEach-Object {
        $columns = $_ -split '\s+'
        if ($columns.Count -ge 6) {
            [PSCustomObject]@{
                "Proto" = $columns[0]
                "Recv-Q" = $columns[1]
                "Send-Q" = $columns[2]
                "Local Address" = $columns[3]
                "Foreign Address" = $columns[4]
                "State" = $columns[5]
            }
        }
    } | Format-Table -AutoSize
    Write-Output $networkActivity

    Write-Host "`n[+] Grabbing current routing information..."
    $routeNetworkActivity = route -n | Select-String -Pattern '(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\S+)' | ForEach-Object {
        $matches = $_.Matches[0].Groups
        [PSCustomObject]@{
            "Destination" = $matches[1].Value
            "Gateway" = $matches[2].Value
            "Genmask" = $matches[3].Value
            "Flags" = $matches[4].Value
            "Metric" = $matches[5].Value
            "Ref" = $matches[6].Value
            "Use" = $matches[7].Value
            "Iface" = $matches[8].Value
        }
    } | Format-Table -AutoSize
    Write-Output $routeNetworkActivity
}


# Define the function to check for currently logged-in users:
function Get-LoggedInUsers {
    $loggedInUsers = who
    Write-Host "`n[+] Currently Logged-In Users:"
    Write-Host $loggedInUsers
}

# Define the function to check if Antivirus is currently installed:
function Check-AVInstalled {
    $avPackages = "clamav", "clamav-daemon", "clamtk", "trellix", "wazuh", "mdatp", "mdatp-*"
    $installedPackages = dpkg-query -W -f='${Package}\n'
    $avInstalled = $avPackages | ForEach-Object { $installedPackages -contains $_ }
    if ($avInstalled -contains $true) {
        Write-Host "`n[+] Antivirus software is installed on the system."
    } else {
        Write-Host "`n[+] Antivirus software is not installed on the system."
    }
}

function Check-CredentialManagerInstalled {
    $credentialManagers = "gnome-keyring", "kwalletmanager", "pass", "seahorse"
    $installed = $credentialManagers | ForEach-Object { which $_ }
    $installedManagers = $installed -ne $null
    if ($installedManagers) {
        Write-Host "`n[+] Credential management tools are installed on the system."
    } else {
        Write-Host "`n[+] Credential management tools are not installed on the system."
    }
}

# Checking for .ps1 files on the target.function Search-PS1Files {function Search-PS1Files {
    function Search-PS1Files {
        Write-Host "Searching for .ps1 files in all directories..."
    
        $ErrorActionPreference = 'SilentlyContinue'
    
        $ps1Files = Get-ChildItem -Path / -Filter *.ps1 -Recurse -ErrorAction SilentlyContinue
    
        $searchResults = @()
    
        if ($ps1Files) {
            $totalFiles = $ps1Files.Count
    
            # Display progress bar
            Write-Progress -Activity "Searching .ps1 files" -Status "Progress:" -PercentComplete 0 -SecondsRemaining -1
    
            foreach ($file in $ps1Files) {
                # Process each .ps1 file
                # Do additional processing if needed
                # For now, just adding the file path to search results
                $searchResults += $file.FullName
            }
    
            Write-Progress -Activity "Searching .ps1 files" -Status "Complete" -PercentComplete 100
        } else {
            Write-Host "No .ps1 files found."
        }
    
        $ErrorActionPreference = 'Continue'
    
        # Output the search results
        $searchResults
    }

    function Search-AWSCredentials {
        Write-Host "`n[+] Searching for AWS credentials on the system..."
    
        $ErrorActionPreference = 'SilentlyContinue'
    
        # Common paths where AWS credentials might be stored
        $pathsToSearch = @(
            "$HOME/.aws/credentials",
            "$HOME/.aws/config",

        )
    
        # Search for credentials in common paths
        foreach ($path in $pathsToSearch) {
            if (Test-Path $path) {
                Write-Host "`nChecking $path for AWS credentials..."
                $content = Get-Content $path
    
                $awsAccessKeys = $content | Select-String -Pattern 'aws_access_key_id'
                $awsSecretKeys = $content | Select-String -Pattern 'aws_secret_access_key'
                $awsSessionTokens = $content | Select-String -Pattern 'aws_session_token'
    
                if ($awsAccessKeys) {
                    Write-Host "`nAWS Access Keys found in $path"
                    $awsAccessKeys | ForEach-Object { Write-Host $_.Line }
                }
    
                if ($awsSecretKeys) {
                    Write-Host "`nAWS Secret Keys found in $path"
                    $awsSecretKeys | ForEach-Object { Write-Host $_.Line }
                }
    
                if ($awsSessionTokens) {
                    Write-Host "`nAWS Session Tokens found in $path"
                    $awsSessionTokens | ForEach-Object { Write-Host $_.Line }
                }
            } else {
                Write-Host "$path not found."
            }
        }
    
        # Search for credentials in environment variables
        Write-Host "`nChecking environment variables for AWS credentials..."
        $envVars = Get-ChildItem Env: | Where-Object { $_.Name -match 'AWS_' }
    
        foreach ($envVar in $envVars) {
            $envVarName = $envVar.Name
            $envVarValue = $envVar.Value
            Write-Host "$envVarName $envVarValue"
        }
    
        $ErrorActionPreference = 'Continue'
    
        Write-Host "`nSearch complete."
    }

    function Search-AzureCredentials {
        Write-Host "`n[+] Searching for Azure credentials on the system..."
    
        # Common paths where Azure credentials might be stored
        $pathsToSearch = @(
            "$HOME/.azure/azureProfile.json",
            "$HOME/.azure/azureProfile",
            "$HOME/.azure/accessTokens.json",
            "$HOME/.azure/accessTokens",
            "~/.azure/msal_token_cache.json"
            "/etc/azure/azureProfile.json",
            "/etc/azure/azureProfile",
            "/etc/azure/accessTokens.json",
            "/etc/azure/accessTokens",
        )
    
        # Search for credentials in common paths
        foreach ($path in $pathsToSearch) {
            if (Test-Path $path) {
                Write-Host "`nChecking $path for Azure credentials..."
                $content = Get-Content $path
    
                $azureTokens = $content | Select-String -Pattern 'accessToken'
                $azureSecretKeys = $content | Select-String -Pattern 'secret'
                $azureVaults = $content | Select-String -Pattern 'keyVault'
    
                if ($azureTokens) {
                    Write-Host "Azure Tokens found in $path"
                    $azureTokens | ForEach-Object { Write-Host $_ }
                }
    
                if ($azureSecretKeys) {
                    Write-Host "Azure Secret Keys found in $path"
                    $azureSecretKeys | ForEach-Object { Write-Host $_ }
                }
    
                if ($azureVaults) {
                    Write-Host "Azure Vaults found in $path"
                    $azureVaults | ForEach-Object { Write-Host $_ }
                }
            } else {
                Write-Host "$path not found."
            }
        }
    
        # Search for credentials in environment variables
        Write-Host "`nChecking environment variables for Azure credentials..."
        $envVars = Get-ChildItem Env: | Where-Object { $_.Name -match 'AZURE_' }
    
        foreach ($envVar in $envVars) {
            Write-Host "$($envVar.Name): $($envVar.Value)"
        }
    
        Write-Host "`nSearch complete."
    }
    
 # Obtaining the current users history and powershell history
 function Review-UserHistory {
    # Review Bash or Shell History
    function Get-ShellHistory {
        Write-Host "`n[+] Reviewing Users Shell History..."
        $shellHistoryPath = "$HOME/.bash_history"
        if (Test-Path $shellHistoryPath) {
            $shellHistory = Get-Content $shellHistoryPath
            Write-Host "Shell History:"
            $shellHistory | ForEach-Object { Write-Host $_ }
        } else {
            Write-Host "`n[+] No user shell history found."
        }
    }

    # Review PowerShell Command History
    function Get-PowerShellHistory {
        Write-Host "`n[+] Reviewing PowerShell Command History..."
        $psHistory = Get-History
        if ($psHistory) {
            Write-Host "PowerShell Command History:"
            $psHistory | ForEach-Object { Write-Host "$($_.Id) $($_.CommandLine)" }
        } else {
            Write-Host "`n[+] No PowerShell command history found."
        }
    }


}   
    




# Main Functions that run the script. You can comment and uncomment certain functions for your privesc checks

# Run the help function after printing the banner
Show-Help

# Function to obtain targets PowerShell Version:
Write-Host "[+] Powershell Version on Target"
Get-Host

# Obtaining OS and Kernel Information Function 
Get-OSInfo

# Checking our target to see if it is joined to a domain controller
Check-ADJoinStatus

# Obtain a current process list running on the target system
Write-Host "`n[+] Gathering Current Proccess List"
Get-Process

# Obtain a current list of local and network drives connected to the target:
Write-Host "`n[+] Checking for local and network drives"
Get-Drives

# Check for current network connections on the target:
Get-NetworkActivity

# Check for users logged in on the target:
Get-LoggedInUsers

# Checking for Antivirus
Check-AVInstalled

# Checking to see if credential manager is installed
Check-CredentialManagerInstalled

# Functions to hunt for credentials or files:
Search-PS1Files
Search-AWSCredentials
Search-AzureCredentials

# Function to search users regular and powershell history
# WARNING: You will get a lot of data from this function.
Review-UserHistory
